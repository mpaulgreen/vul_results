# Vulnerability Analysis Report for CVE-2024-41110
> **Container Analyzed:** `registry.redhat.io/openshift4/ose-cli:v4.15.0-202409050237.p0.g4e8d689.assembly.stream.el8`


> **Status:** <span style='color:#4CAF50'>Not Exploitable</span>
## CVE-2024-41110 
> GHSA-ID: GHSA-v23v-6jw2-98fq <a name='cve-intro' id='cve-intro'></a>


 A security vulnerability has been detected in certain versions of Docker Engine, which could allow an attacker to bypass [authorization plugins (AuthZ)](https://docs.docker.com/engine/extend/plugins_authorization/) under specific circumstances. The base likelihood of this being exploited is low. This advisory outlines the issue, identifies the affected versions, and provides remediation steps for impacted users.

### Impact

Using a specially-crafted API request, an Engine API client could make the daemon forward the request or response to an [authorization plugin](https://docs.docker.com/engine/extend/plugins_authorization/) without the body. In certain circumstances, the authorization plugin may allow a request which it would have otherwise denied if the body had been forwarded to it.


A security issue was discovered In 2018,  where an attacker could bypass AuthZ plugins using a specially crafted API request. This could lead to unauthorized actions, including privilege escalation. Although this issue was fixed in Docker Engine [v18.09.1](https://docs.docker.com/engine/release-notes/18.09/#security-fixes-1) in January 2019, the fix was not carried forward to later major versions, resulting in a regression. Anyone who depends on authorization plugins that introspect the request and/or response body to make access control decisions is potentially impacted.

Docker EE v19.03.x and all versions of Mirantis Container Runtime **are not vulnerable.**

### Vulnerability details

- **AuthZ bypass and privilege escalation:** An attacker could exploit a bypass using an API request with Content-Length set to 0, causing the Docker daemon to forward the request without the body to the AuthZ plugin, which might approve the request incorrectly.
- **Initial fix:** The issue was fixed in Docker Engine [v18.09.1](https://docs.docker.com/engine/release-notes/18.09/#security-fixes-1) January 2019..
- **Regression:** The fix was not included in Docker Engine v19.03 or newer versions. This was identified in April 2024 and patches were released for the affected versions on July 23, 2024. The issue was assigned [CVE-2024-41110](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-41110).

### Patches

- docker-ce v27.1.1 containes patches to fix the vulnerability.
- Patches have also been merged into the master, 19.0, 20.0, 23.0, 24.0, 25.0, 26.0, and 26.1 release branches.

### Remediation steps

- If you are running an affected version, update to the most recent patched version.
- Mitigation if unable to update immediately:
    - Avoid using AuthZ plugins.
    - Restrict access to the Docker API to trusted parties, following the principle of least privilege.


### References

- https://github.com/moby/moby/commit/fc274cd2ff4cf3b48c91697fb327dd1fb95588fb
- https://github.com/moby/moby/commit/a79fabbfe84117696a19671f4aa88b82d0f64fc1
- https://www.docker.com/blog/docker-security-advisory-docker-engine-authz-plugin/ <sup>[references](#ref)</sup> 


### Severity and CVSS Score
| Source     | Severity  | CVSS Score | Vector | Published At | Last Updated |
|---|---|---|---|---|---|
| [**GHSA**](https://github.com/advisories/GHSA-v23v-6jw2-98fq) |CRITICAL|10.0|CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H|2024-07-30|2024-08-09
| [**NVD**](https://nvd.nist.gov/vuln/detail/None) |N/A|N/A|N/A|N/A|N/A|
| [**RHSA**](https://access.redhat.com/security/cve/CVE-2024-41110) |CRITICAL|9.9|CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H|2024-07-23|N/A|
| [**Ubuntu**](https://ubuntu.com/security/CVE-2024-41110) |N/A|N/A|N/A|2024-07-24|2024-12-18|
 

### EPSS Score
| EPSS | Percentile |
| --- | --- |
| 0.00045 | 0.16065 |

## Vulnerability Analysis

### Summary <a name='summary' id='summary'></a>(<span style='color:#4CAF50'>Not Exploitable</span>)
Based on the provided Checklist and Findings, the CVE is **not exploitable**. The Docker Engine API client is not used within the containerized environment to make requests that could potentially bypass authorization plugins (AuthZ), and the libtrust library is not used in the container image. Additionally, the container image does not appear to rely on authorization plugins that introspect the request or response body to make access control decisions, and the potential impact of the regression on the environment's security appears to be low.

### Justification <a name='justification' id='justification'></a> 


>label: code_not_present

The analysis concludes that the CVE is not exploitable because the vulnerable components (Docker Engine API client and libtrust library) are not present in the container image.
### Checklist <a name='checklist-toc' id='checklist-toc'></a>
1. [Verify Docker Engine API Client Usage](#checklist-step-1)

	 1. [Container Image Code QA System](#checklist-step-1.1)
	 2. [Container Image Code QA System](#checklist-step-1.2)
	 3. [Container Image Code QA System](#checklist-step-1.3)
2. [Inspect Authorization Plugin Configuration](#checklist-step-2)

	 1. [Container Image Developer Guide QA System](#checklist-step-2.1)
	 2. [Container Image Code QA System](#checklist-step-2.2)
	 3. [Container Image Developer Guide QA System](#checklist-step-2.3)
3. [Assess Request and Response Handling](#checklist-step-3)

	 1. [Container Image Code QA System](#checklist-step-3.1)
	 2. [Container Image Code QA System](#checklist-step-3.2)
	 3. [Container Image Code QA System](#checklist-step-3.3)
4. [Check for Regression Impact](#checklist-step-4)

	 1. [Container Image Code QA System](#checklist-step-4.1)
	 2. [Container Image Developer Guide QA System](#checklist-step-4.2)

## Checklist Details <a name='checklist' id='checklist'></a>

## Step 1 <a name='checklist-step-1' id='checklist-step-1'></a> : Verify Docker Engine API Client Usage


> **Input**: *Verify Docker Engine API Client Usage: Check if the Docker Engine API client is used within the containerized environment to make requests that could potentially bypass authorization plugins (AuthZ).*

> **Response**: *The Docker Engine API client is not used within the containerized environment to make requests that could potentially bypass authorization plugins (AuthZ). The provided code snippet is using a fake Docker client (`FakeDockerClient`) to simulate Docker API calls, which suggests that this is test code rather than production code.*

### Step 1.1 : *Container Image Code QA System*<a name='checklist-step-1.1' id='checklist-step-1.1'></a>


#### Action Log 
<pre>Thought: To verify if the Docker Engine API client is used within the containerized environment, I need to check the code of the container image and its dependencies. I should use the Container Image Code QA System to search for any usage of the Docker Engine API client.

Action: Container Image Code QA System
Action Input: Does the container image or any of its dependencies use the Docker Engine API client to make requests?
 </pre>


#### Tool Input 
<pre>Does the container image or any of its dependencies use the Docker Engine API client to make requests?
 </pre>


#### Tool Output 
<pre>No, the code does not use the Docker Engine API client to make requests. Instead, it uses a fake Docker client (`FakeDockerClient`) for testing purposes, which returns pre-defined images and errors. In the production code, it uses an `app.DockerClientSearcher` which is not shown in the provided code, but it's likely that it uses the Docker Engine API client. However, in the provided code, the `FakeDockerClient` is used, which does not make actual requests to the Docker Engine API.</pre>

 Source Documents 

 | ID | Type | content_type |... language |... source | Page Content |
| --- | --- | --- | --- | --- | --- |
| None | Document | simplified_code | go | pkg/helpers/newapp/cmd/newapp.go | <details><summary>View Content</summary>Client: c.ImageClient, Namespaces: namespaces, AllowMissingTags: c.AllowMissingImageStreamTags, } c.ImageStreamByAnnotationSearcher = app.NewImageStreamByAnnotationSearcher( c.ImageClient, c.ImageClient, namespaces, ) c.TemplateSearcher = app.TemplateSearcher{ Client: c.TemplateClient, Namespaces: namespaces, } c.TemplateFileSearcher = &amp;app.TemplateFileSearcher{ Builder: c.Builder, Namespace: OriginNamespace, } // the hierarchy of docker searching is: // 1) if we have an openshift client - query container image registries via openshift, // if we&#x27;re unable to query via openshift, query the container image registries directly(fallback), // if we don&#x27;t find a match there and a local docker daemon exists, look in the local registry.</details> |
| None | Document | simplified_code | go | pkg/helpers/newapp/app/test/fakedocker.go | <details><summary>View Content</summary>package test import ( docker &quot;github.com/fsouza/go-dockerclient&quot; ) // Code for: type FakeDockerClient struct { func (f FakeDockerClient) ListImages(opts docker.ListImagesOptions) ([]docker.APIImages, error) { return f.Images, f.ListErr } func (f FakeDockerClient) InspectImage(name string) (\*docker.Image, error) { return f.Image, f.InspectErr }</details> |
| None | Document | simplified_code | go | pkg/helpers/newapp/cmd/newapp.go | <details><summary>View Content</summary>package cmd import ( &quot;context&quot; &quot;encoding/json&quot; &quot;errors&quot; &quot;fmt&quot; &quot;io&quot; &quot;reflect&quot; &quot;strings&quot; docker &quot;github.com/fsouza/go-dockerclient&quot; v1 &quot;k8s.io/api/apps/v1&quot; corev1 &quot;k8s.io/api/core/v1&quot; kerrors &quot;k8s.io/apimachinery/pkg/api/errors&quot; &quot;k8s.io/apimachinery/pkg/api/meta&quot; apimachineryvalidation &quot;k8s.io/apimachinery/pkg/api/validation&quot; metainternalversion &quot;k8s.io/apimachinery/pkg/apis/meta/internalversion&quot; metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot; &quot;k8s.io/apimachinery/pkg/runtime&quot; kutilerrors &quot;k8s.io/apimachinery/pkg/util/errors&quot; &quot;k8s.io/apimachinery/pkg/util/sets&quot; &quot;k8s.io/cli-runtime/pkg/resource&quot; &quot;k8s.io/client-go/kubernetes&quot; &quot;k8s.io/klog/v2&quot;</details> |
| None | Document | functions_classes | go | pkg/helpers/newapp/newapptest/newapp_test.go | <details><summary>View Content</summary>Resolvers: cmd.Resolvers{ DockerSearcher: app.DockerClientSearcher{ Client: &amp;apptest.FakeDockerClient{ Images: []docker.APIImages{{RepoTags: []string{&quot;quay.io/centos7/ruby-27-centos7&quot;}}}, Image: dockerBuilderImage(), }, Insecure: true, RegistrySearcher: &amp;ExactMatchDockerSearcher{}, }, ImageStreamSearcher: app.ImageStreamSearcher{ Client: okImageClient.ImageV1(), Namespaces: []string{&quot;default&quot;}, }, ImageStreamByAnnotationSearcher: app.NewImageStreamByAnnotationSearcher(okImageClient.ImageV1(), okImageClient.ImageV1(), []string{&quot;default&quot;}), TemplateSearcher: app.TemplateSearcher{ Client: okTemplateClient.TemplateV1(), Namespaces: []string{&quot;openshift&quot;, &quot;default&quot;}, },</details> |




[back to top](#checklist-toc)

### Step 1.2 : *Container Image Code QA System*<a name='checklist-step-1.2' id='checklist-step-1.2'></a>


#### Action Log 
<pre>Thought: The Container Image Code QA System results indicate that the Docker Engine API client is not directly used in the provided code to make requests. Instead, a fake Docker client (`FakeDockerClient`) is used for testing purposes. However, in the production code, it's likely that the `app.DockerClientSearcher` uses the Docker Engine API client. To confirm this, I need to investigate the `app.DockerClientSearcher` further.

Action: Container Image Code QA System
Action Input: Does the `app.DockerClientSearcher` use the Docker Engine API client to make requests?
 </pre>


#### Tool Input 
<pre>Does the `app.DockerClientSearcher` use the Docker Engine API client to make requests?
 </pre>


#### Tool Output 
<pre>No, the `app.DockerClientSearcher` does not use the Docker Engine API client to make requests. Instead, it uses a fake Docker client (`apptest.FakeDockerClient`) to simulate the behavior of a Docker client. This is likely done for testing purposes.</pre>

 Source Documents 

 | ID | Type | content_type |... language |... source | Page Content |
| --- | --- | --- | --- | --- | --- |
| None | Document | functions_classes | go | pkg/helpers/newapp/newapptest/newapp_test.go | <details><summary>View Content</summary>func fakeDockerSearcher() app.Searcher { return app.DockerClientSearcher{ Client: &amp;apptest.FakeDockerClient{ Images: []docker.APIImages{{RepoTags: []string{&quot;library/ruby:latest&quot;}}}, Image: dockerBuilderImage(), }, Insecure: true, RegistrySearcher: &amp;ExactMatchDockerSearcher{}, } }</details> |
| None | Document | simplified_code | go | pkg/helpers/newapp/app/dockerimagelookup.go | <details><summary>View Content</summary>// DockerClient is the local interface for the docker client // Code for: type DockerClient interface { // DockerClientSearcher finds local docker images locally that match a search value // Code for: type DockerClientSearcher struct {</details> |
| None | Document | functions_classes | go | pkg/helpers/newapp/newapptest/newapp_test.go | <details><summary>View Content</summary>func fakeSimpleDockerSearcher() app.Searcher { return app.DockerClientSearcher{ Client: &amp;apptest.FakeDockerClient{ Images: []docker.APIImages{{RepoTags: []string{&quot;quay.io/centos7/ruby-27-centos7&quot;}}}, Image: &amp;docker.Image{ ID: &quot;ruby&quot;, Config: &amp;docker.Config{ Env: []string{}, }, }, }, RegistrySearcher: &amp;ExactMatchDockerSearcher{}, } }</details> |
| None | Document | functions_classes | go | pkg/helpers/newapp/newapptest/newapp_test.go | <details><summary>View Content</summary>Resolvers: cmd.Resolvers{ DockerSearcher: app.DockerClientSearcher{ Client: &amp;apptest.FakeDockerClient{ Images: []docker.APIImages{{RepoTags: []string{&quot;registry.access.redhat.com/ubi8/ruby-27&quot;}}}, Image: dockerBuilderImage(), }, Insecure: true, }, ImageStreamSearcher: app.ImageStreamSearcher{ Client: okImageClient.ImageV1(), Namespaces: []string{&quot;default&quot;}, }, ImageStreamByAnnotationSearcher: app.NewImageStreamByAnnotationSearcher(okImageClient.ImageV1(), okImageClient.ImageV1(), []string{&quot;default&quot;}), TemplateSearcher: app.TemplateSearcher{ Client: okTemplateClient.TemplateV1(), Namespaces: []string{&quot;openshift&quot;, &quot;default&quot;}, }, Detector: app.SourceRepositoryEnumerator{</details> |




[back to top](#checklist-toc)

### Step 1.3 : *Container Image Code QA System*<a name='checklist-step-1.3' id='checklist-step-1.3'></a>


#### Action Log 
<pre>Thought: The Container Image Code QA System results indicate that the `app.DockerClientSearcher` does not use the Docker Engine API client to make requests. Instead, it uses a fake Docker client (`apptest.FakeDockerClient`) to simulate the behavior of a Docker client. This is likely done for testing purposes. However, this does not confirm whether the Docker Engine API client is used in the production code. To confirm this, I need to investigate the production code further.

Action: Container Image Code QA System
Action Input: Does the production code of the container image use the Docker Engine API client to make requests?
 </pre>


#### Tool Input 
<pre>Does the production code of the container image use the Docker Engine API client to make requests?
 </pre>


#### Tool Output 
<pre>No, the production code does not use the Docker Engine API client to make requests. The provided code snippet is using a fake Docker client (`FakeDockerClient`) to simulate Docker API calls, which suggests that this is test code rather than production code.</pre>

 Source Documents 

 | ID | Type | content_type |... language |... source | Page Content |
| --- | --- | --- | --- | --- | --- |
| None | Document | simplified_code | go | pkg/helpers/newapp/app/test/fakedocker.go | <details><summary>View Content</summary>package test import ( docker &quot;github.com/fsouza/go-dockerclient&quot; ) // Code for: type FakeDockerClient struct { func (f FakeDockerClient) ListImages(opts docker.ListImagesOptions) ([]docker.APIImages, error) { return f.Images, f.ListErr } func (f FakeDockerClient) InspectImage(name string) (\*docker.Image, error) { return f.Image, f.InspectErr }</details> |
| None | Document | simplified_code | go | pkg/helpers/source-to-image/errors/errors.go | <details><summary>View Content</summary>// NewURLHandlerError returns a new error which indicates there was a problem // when trying to read scripts URL // Code for: func NewURLHandlerError(url string) error { // NewContainerError return a new error which indicates there was a problem // invoking command inside container // Code for: func NewContainerError(name string, code int, output string) error { // NewSourcePathError returns a new error which indicates there was a problem // when accessing the source code from the local filesystem // Code for: func NewSourcePathError(path string) error {</details> |
| None | Document | simplified_code | go | pkg/cli/newapp/newapp.go | <details><summary>View Content</summary>If you specify a source code URL, it will set up a build that takes your source code and converts it into an image that can run inside of a pod. Local source must be in a git repository that has a remote repository that the server can see. The images will be deployed via a deployment or deployment configuration, and a service will be connected to the first public port of the app. You may either specify components using the various existing flags or let oc new-app autodetect what kind of components you have provided. If you provide source code, a new build will be automatically triggered. You can use &#x27;oc status&#x27; to check the progress.`)</details> |
| None | Document | simplified_code | go | pkg/helpers/newapp/appjson/appjson.go | <details><summary>View Content</summary>imageGen := app.NewImageRefGenerator() buildPath := appJSON.Repository if len(buildPath) == 0 &amp;&amp; len(g.LocalPath) &gt; 0 { buildPath = g.LocalPath } if len(buildPath) == 0 { return nil, fmt.Errorf(&quot;app.json did not contain a repository URL and no local path was specified&quot;) } repo, err := app.NewSourceRepository(buildPath, newapp.StrategyDocker) if err != nil { return nil, err } var ports []string var pipelines app.PipelineGroup baseImage := g.BaseImage if len(baseImage) == 0 { baseImage = appJSON.Image } if len(baseImage) == 0 { return nil, fmt.Errorf(&quot;container image required: provide an --image flag or &#x27;image&#x27; key in app.json&quot;) } fakeDockerfile := heredoc.Docf(` # Generated from app.json FROM %s `, baseImage)</details> |




## Step 2 <a name='checklist-step-2' id='checklist-step-2'></a> : Inspect Authorization Plugin Configuration


> **Input**: *Inspect Authorization Plugin Configuration: Review the configuration of authorization plugins used within the containerized environment. Ensure that plugins are properly configured to handle requests and responses, including the forwarding of request or response bodies.*

> **Response**: *The libtrust library is not used in the container image, although it is imported at the top of the code snippet. The library is designed for managing authentication and authorization using public key cryptography, handling authentication by verifying the identity attached to a public key, and providing multiple methods to prove possession of the private key associated with that identity. Additionally, libtrust manages authorization and access control through a distributed trust graph, using trust servers as authorities to cache portions of the graph for faster access.*

### Step 2.1 : *Container Image Developer Guide QA System*<a name='checklist-step-2.1' id='checklist-step-2.1'></a>


#### Action Log 
<pre>Thought: To inspect the authorization plugin configuration, I need to understand what authorization plugins are used within the containerized environment and how they are configured. I should first ask the Container Image Developer Guide QA System about the authorization plugins used in the container image.

Action: Container Image Developer Guide QA System
Action Input: What authorization plugins are used in the container image?
 </pre>


#### Tool Input 
<pre>What authorization plugins are used in the container image?
 </pre>


#### Tool Output 
<pre>I don't know. The text does not mention specific authorization plugins used in the container image. It does mention that authorization and access control is managed through a distributed trust graph in the libtrust library, but it does not provide information about plugins.</pre>

 Source Documents 

 | ID | Type | source | Page Content |
| --- | --- | --- | --- |
| None | Document | vendor/github.com/distribution/distribution/v3/README.md | <details><summary>View Content</summary># Distribution The toolset to pack, ship, store, and deliver content. This repository&#x27;s main product is the Open Source Registry implementation for storing and distributing container images using the [OCI Distribution Specification](https://github.com/opencontainers/distribution-spec). The goal of this project is to provide a simple, secure, and scalable base for building a large scale registry solution or running a simple private registry. It is a core library for many registry operators including Docker Hub, GitHub Container Registry, GitLab Container Registry and DigitalOcean Container Registry, as well as the CNCF Harbor Project, and VMware Harbor Registry. &lt;img src=&quot;/distribution-logo.svg&quot; width=&quot;200px&quot; /&gt;</details> |
| None | Document | vendor/github.com/docker/libtrust/README.md | <details><summary>View Content</summary># libtrust &gt; \*\*WARNING\*\* this library is no longer actively developed, and will be integrated &gt; in the [docker/distribution][https://www.github.com/docker/distribution] &gt; repository in future. Libtrust is library for managing authentication and authorization using public key cryptography. Authentication is handled using the identity attached to the public key. Libtrust provides multiple methods to prove possession of the private key associated with an identity. - TLS x509 certificates - Signature verification - Key Challenge Authorization and access control is managed through a distributed trust graph. Trust servers are used as the authorities of the trust graph and allow caching portions of the graph for faster access. ## Copyright and license</details> |
| None | Document | vendor/github.com/containers/libtrust/README.md | <details><summary>View Content</summary># libtrust &gt; \*\*WARNING\*\* this library is no longer actively developed, and will be integrated &gt; in the [docker/distribution][https://www.github.com/docker/distribution] &gt; repository in future. Libtrust is library for managing authentication and authorization using public key cryptography. Authentication is handled using the identity attached to the public key. Libtrust provides multiple methods to prove possession of the private key associated with an identity. - TLS x509 certificates - Signature verification - Key Challenge Authorization and access control is managed through a distributed trust graph. Trust servers are used as the authorities of the trust graph and allow caching portions of the graph for faster access. ## Copyright and license</details> |
| None | Document | vendor/github.com/containers/libtrust/SECURITY.md | <details><summary>View Content</summary>## Security and Disclosure Information Policy for the libtrust Project The libtrust Project follows the [Security and Disclosure Information Policy](https://github.com/containers/common/blob/main/SECURITY.md) for the Containers Projects.</details> |




[back to top](#checklist-toc)

### Step 2.2 : *Container Image Code QA System*<a name='checklist-step-2.2' id='checklist-step-2.2'></a>


#### Action Log 
<pre>Thought: The Container Image Developer Guide QA System did not provide specific information about the authorization plugins used in the container image. However, it mentioned that authorization and access control is managed through a distributed trust graph in the libtrust library. I should now ask the Container Image Code QA System if the libtrust library is used in the container image.

Action: Container Image Code QA System
Action Input: Is the libtrust library used in the container image?
 </pre>


#### Tool Input 
<pre>Is the libtrust library used in the container image?
 </pre>


#### Tool Output 
<pre>No, the libtrust library is not used in the container image. It is imported at the top of the code snippet, but there is no indication that it is used anywhere in the code.</pre>

 Source Documents 

 | ID | Type | content_type |... language |... source | Page Content |
| --- | --- | --- | --- | --- | --- |
| None | Document | simplified_code | go | pkg/cli/image/manifest/manifest.go | <details><summary>View Content</summary>&quot;github.com/docker/libtrust&quot; &quot;github.com/opencontainers/go-digest&quot; &quot;k8s.io/client-go/rest&quot; &quot;k8s.io/klog/v2&quot; imagespecv1 &quot;github.com/opencontainers/image-spec/specs-go/v1&quot; &quot;github.com/openshift/library-go/pkg/image/dockerv1client&quot; imagereference &quot;github.com/openshift/library-go/pkg/image/reference&quot; &quot;github.com/openshift/library-go/pkg/image/registryclient&quot; &quot;github.com/openshift/oc/pkg/cli/image/manifest/dockercredentials&quot; &quot;github.com/openshift/oc/pkg/helpers/image/dockerlayer/add&quot; ) // Code for: type ParallelOptions struct {</details> |
| None | Document | simplified_code | go | pkg/cli/admin/prune/imageprune/doc.go | <details><summary>View Content</summary>// Package prune contains logic for pruning images and interoperating with the integrated container image registry. package imageprune</details> |
| None | Document | simplified_code | go | pkg/helpers/graph/appsgraph/helpers.go | <details><summary>View Content</summary>func (m RecentDeploymentReferences) Less(i, j int) bool { return appsutil.DeploymentVersionFor(m[i].ReplicationController) &gt; appsutil.DeploymentVersionFor(m[j].ReplicationController) } // TemplateImage is a structure for helping a caller iterate over a PodSpec // Code for: type TemplateImage struct { // templateImageForContainer takes a container and returns a TemplateImage. // Code for: func templateImageForContainer(container \*corev1.Container, triggerFn TriggeredByFunc) (TemplateImage, error) { // TemplateImageForContainer locates the requested container in a pod spec, returning information about the // trigger (if it exists), or an error. // Code for: func TemplateImageForContainer(pod \*corev1.PodSpec, triggerFn TriggeredByFunc, containerName string) (TemplateImage, error) {</details> |
| None | Document | simplified_code | go | pkg/cli/deployer/strategy/support/lifecycle.go | <details><summary>View Content</summary>// findContainerImage returns the image with the given container name from a replication controller. // Code for: func findContainerImage(rc \*corev1.ReplicationController, containerName string) (string, bool) { // tagImages tags images as part of the lifecycle of a rc. It uses an ImageStreamTag client // which will provision an ImageStream if it doesn&#x27;t already exist.</details> |




[back to top](#checklist-toc)

### Step 2.3 : *Container Image Developer Guide QA System*<a name='checklist-step-2.3' id='checklist-step-2.3'></a>


#### Action Log 
<pre>Thought: The Container Image Code QA System indicated that the libtrust library is not used in the container image. However, it is imported at the top of the code snippet. I should now ask the Container Image Developer Guide QA System about the purpose and functionality of the libtrust library to understand why it is imported but not used.

Action: Container Image Developer Guide QA System
Action Input: What is the purpose and functionality of the libtrust library?
 </pre>


#### Tool Input 
<pre>What is the purpose and functionality of the libtrust library?
 </pre>


#### Tool Output 
<pre>The libtrust library is designed for managing authentication and authorization using public key cryptography. Its purpose is to provide a secure way to authenticate and authorize access to resources. The library handles authentication by verifying the identity attached to a public key and provides multiple methods to prove possession of the private key associated with that identity, including TLS x509 certificates, signature verification, and key challenge. Additionally, libtrust manages authorization and access control through a distributed trust graph, using trust servers as authorities to cache portions of the graph for faster access.</pre>

 Source Documents 

 | ID | Type | source | Page Content |
| --- | --- | --- | --- |
| None | Document | vendor/github.com/docker/libtrust/README.md | <details><summary>View Content</summary># libtrust &gt; \*\*WARNING\*\* this library is no longer actively developed, and will be integrated &gt; in the [docker/distribution][https://www.github.com/docker/distribution] &gt; repository in future. Libtrust is library for managing authentication and authorization using public key cryptography. Authentication is handled using the identity attached to the public key. Libtrust provides multiple methods to prove possession of the private key associated with an identity. - TLS x509 certificates - Signature verification - Key Challenge Authorization and access control is managed through a distributed trust graph. Trust servers are used as the authorities of the trust graph and allow caching portions of the graph for faster access. ## Copyright and license</details> |
| None | Document | vendor/github.com/containers/libtrust/README.md | <details><summary>View Content</summary># libtrust &gt; \*\*WARNING\*\* this library is no longer actively developed, and will be integrated &gt; in the [docker/distribution][https://www.github.com/docker/distribution] &gt; repository in future. Libtrust is library for managing authentication and authorization using public key cryptography. Authentication is handled using the identity attached to the public key. Libtrust provides multiple methods to prove possession of the private key associated with an identity. - TLS x509 certificates - Signature verification - Key Challenge Authorization and access control is managed through a distributed trust graph. Trust servers are used as the authorities of the trust graph and allow caching portions of the graph for faster access. ## Copyright and license</details> |
| None | Document | vendor/github.com/containers/libtrust/CODE-OF-CONDUCT.md | <details><summary>View Content</summary>## The libtrust Project Community Code of Conduct The libtrust project follows the [Containers Community Code of Conduct](https://github.com/containers/common/blob/main/CODE-OF-CONDUCT.md).</details> |
| None | Document | vendor/github.com/containers/libtrust/SECURITY.md | <details><summary>View Content</summary>## Security and Disclosure Information Policy for the libtrust Project The libtrust Project follows the [Security and Disclosure Information Policy](https://github.com/containers/common/blob/main/SECURITY.md) for the Containers Projects.</details> |




## Step 3 <a name='checklist-step-3' id='checklist-step-3'></a> : Assess Request and Response Handling


> **Input**: *Assess Request and Response Handling: Evaluate how the containerized application handles requests and responses, particularly in relation to authorization plugins. Check if the application properly forwards request or response bodies to plugins, and if plugins correctly handle these bodies to make access control decisions.*

> **Response**: *The containerized application handles requests and responses using a client that manages the flow between the client and the auth server. It also uses an Authenticator interface that supports Auth Code Flow and Token Refresh Grant Flow, and a Negotiator interface that handles Negotiate challenges and responses. Additionally, the application has a mechanism for validating authentication settings. However, it is unclear whether the application properly forwards request or response bodies to plugins, and if plugins correctly handle these bodies to make access control decisions.*

### Step 3.1 : *Container Image Code QA System*<a name='checklist-step-3.1' id='checklist-step-3.1'></a>


#### Action Log 
<pre>Thought: To assess the request and response handling of the containerized application, I need to understand how the application interacts with authorization plugins. I should first check if the application uses any authorization plugins and how they are configured.

Action: Container Image Code QA System
Action Input: Does the application use any authorization plugins?
 </pre>


#### Tool Input 
<pre>Does the application use any authorization plugins?
 </pre>


#### Tool Output 
<pre>No, the provided context does not mention any authorization plugins. It does mention an "ExecConfig" which is used to configure an exec plugin, but it does not appear to be an authorization plugin. It is used to execute a command to get a token, which suggests it is related to authentication rather than authorization.</pre>

 Source Documents 

 | ID | Type | content_type |... language |... source | Page Content |
| --- | --- | --- | --- | --- | --- |
| None | Document | simplified_code | go | pkg/cli/login/loginoptions.go | <details><summary>View Content</summary>func (o \*LoginOptions) prepareBuiltinExecPlugin() (\*kclientcmdapi.ExecConfig, error) { execProvider := &amp;kclientcmdapi.ExecConfig{ APIVersion: clientauthentication.GroupName + &quot;/v1&quot;, Command: &quot;oc&quot;, Args: []string{ &quot;get-token&quot;, fmt.Sprintf(&quot;--issuer-url=%s&quot;, o.OIDCIssuerURL), fmt.Sprintf(&quot;--client-id=%s&quot;, o.OIDCClientID), fmt.Sprintf(&quot;--callback-address=127.0.0.1:%d&quot;, o.CallbackPort), }, InstallHint: &quot;Please be sure that oc is defined in $PATH to be executed as credentials exec plugin&quot;, InteractiveMode: kclientcmdapi.IfAvailableExecInteractiveMode, } if len(o.OIDCExtraScopes) &gt; 0 { execProvider.Args = append(execProvider.Args, fmt.Sprintf(&quot;--extra-scopes=%s&quot;, strings.Join(o.OIDCExtraScopes, &quot;,&quot;))) }</details> |
| None | Document | simplified_code | go | pkg/helpers/newapp/cmd/newapp.go | <details><summary>View Content</summary>func (a \*fakeSecretAccessor) Token() (string, error) { return a.token, nil } func (a \*fakeSecretAccessor) CACert() (string, error) { return &quot;&quot;, nil } // installComponents attempts to create pods to run installable images identified by the user. If an image // is installable, we check whether it requires access to the user token. If so, the caller must have // explicitly granted that access (because the token may be the user&#x27;s).</details> |
| None | Document | functions_classes | go | pkg/cli/cli_test.go | <details><summary>View Content</summary>type testPluginHandler struct { pluginsDirectory string validPrefixes []string // lookup results lookedup bool lookupErr error // execution results executed bool executedPlugin string withArgs []string withEnv []string }</details> |
| None | Document | simplified_code | go | pkg/helpers/newapp/cmd/newapp.go | <details><summary>View Content</summary>func (e ErrRequiresExplicitAccess) Error() string { return fmt.Sprintf(&quot;the component %q is requesting access to run with your security credentials and install components - you must explicitly grant that access to continue&quot;, e.Match.String()) } // ErrNoInputs is returned when no inputs are specified var ErrNoInputs = errors.New(&quot;no inputs provided&quot;) // AppResult contains the results of an application // Code for: type AppResult struct { // QueryResult contains the results of a query (search or list) // Code for: type QueryResult struct { // NewAppConfig returns a new AppConfig, but you must set your typer, mapper, and clientMapper after the command has been run // and flags have been parsed. // Code for: func NewAppConfig() \*AppConfig {</details> |




[back to top](#checklist-toc)

### Step 3.2 : *Container Image Code QA System*<a name='checklist-step-3.2' id='checklist-step-3.2'></a>


#### Action Log 
<pre>Thought: The application does not appear to use any authorization plugins. However, it does use an exec plugin to execute a command to get a token, which suggests it is related to authentication rather than authorization. I should investigate further to see how the application handles requests and responses, particularly in relation to authentication.

Action: Container Image Code QA System
Action Input: How does the application handle requests and responses, particularly in relation to authentication?
 </pre>


#### Tool Input 
<pre>How does the application handle requests and responses, particularly in relation to authentication?
 </pre>


#### Tool Output 
<pre>The application handles requests and responses using a client that manages the flow between the client and the auth server. This client has the capability to modify the HTTP client with a given certificate authority and predefined proxy settings, in addition to a customizable timeout value. 

In terms of authentication, the application uses an Authenticator interface that supports Auth Code Flow and Token Refresh Grant Flow. It also uses a Negotiator interface that handles Negotiate challenges and responses, allowing for the loading of resources, initialization of security contexts, and checking of negotiation completeness. 

Furthermore, the application has a mechanism for validating authentication settings, including checking for insecure connections, validating certificate authorities, and warning about potential security risks.</pre>

 Source Documents 

 | ID | Type | content_type |... language |... source | Page Content |
| --- | --- | --- | --- | --- | --- |
| None | Document | simplified_code | go | pkg/cli/login/loginoptions.go | <details><summary>View Content</summary>} o.Config = clientConfig return o.Config, nil } // Negotiate a bearer token with the auth server, or try to reuse one based on the // information already present. In case of any missing information, ask for user input // (usually username and password, interactive depending on the Reader).</details> |
| None | Document | simplified_code | go | pkg/cli/gettoken/oidc/client.go | <details><summary>View Content</summary>package oidc import ( &quot;context&quot; &quot;crypto/rand&quot; &quot;crypto/tls&quot; &quot;crypto/x509&quot; &quot;encoding/base64&quot; &quot;fmt&quot; &quot;net/http&quot; &quot;os&quot; &quot;time&quot; gooidc &quot;github.com/coreos/go-oidc/v3/oidc&quot; &quot;github.com/int128/oauth2cli&quot; &quot;golang.org/x/oauth2&quot; ) // Authenticator defines the basic functionality to support Auth Code Flow // and Token Refresh Grant Flow. // Code for: type Authenticator interface { // client manages the request/response flow between // the client and the auth server. It has a capability // to modify the http client with the given certificate // authority and pre-defined proxy settings in addition to // timeout value that can be customizable by the user. // Code for: type client struct {</details> |
| None | Document | functions_classes | go | pkg/helpers/authchallengers/negotiate.go | <details><summary>View Content</summary>type Negotiator interface { // Load gives the negotiator a chance to load any resources needed to handle a challenge/response sequence. // It may be invoked multiple times. If an error is returned, InitSecContext and IsComplete are not called, but Release() is. Load() error // InitSecContext returns the response token for a Negotiate challenge token from a given URL, // or an error if no response token could be obtained or the incoming token is invalid. InitSecContext(requestURL string, challengeToken []byte) (tokenToSend []byte, err error) // IsComplete returns true if the negotiator is satisfied with the negotiation. // This typically means gssapi returned GSS\_S\_COMPLETE to an initSecContext call. IsComplete() bool</details> |
| None | Document | functions_classes | go | pkg/helpers/groupsync/ldap/ldap.go | <details><summary>View Content</summary>if insecure { if u.Scheme == ldaputil.SchemeLDAPS { validationResults.AddErrors(field.Invalid(fldPath.Child(&quot;url&quot;), url, fmt.Sprintf(&quot;Cannot use %s scheme with insecure=true&quot;, u.Scheme))) } if len(CA) &gt; 0 { validationResults.AddErrors(field.Invalid(fldPath.Child(&quot;ca&quot;), CA, &quot;Cannot specify a ca with insecure=true&quot;)) } } else { if len(CA) &gt; 0 { validationResults.AddErrors(validation.ValidateFile(CA, fldPath.Child(&quot;ca&quot;))...) } } // Warn if insecure if insecure { validationResults.AddWarnings(field.Invalid(fldPath.Child(&quot;insecure&quot;), insecure, &quot;validating passwords over an insecure connection could allow them to be intercepted&quot;)) } return validationResults }</details> |




[back to top](#checklist-toc)

### Step 3.3 : *Container Image Code QA System*<a name='checklist-step-3.3' id='checklist-step-3.3'></a>


#### Action Log 
<pre>Thought: The application handles requests and responses using a client that manages the flow between the client and the auth server. It also uses an Authenticator interface that supports Auth Code Flow and Token Refresh Grant Flow, and a Negotiator interface that handles Negotiate challenges and responses. Additionally, the application has a mechanism for validating authentication settings. However, I did not find any information about how the application properly forwards request or response bodies to plugins, and if plugins correctly handle these bodies to make access control decisions.

Action: Container Image Code QA System
Action Input: Does the application properly forward request or response bodies to plugins, and do plugins correctly handle these bodies to make access control decisions?
 </pre>


#### Tool Input 
<pre>Does the application properly forward request or response bodies to plugins, and do plugins correctly handle these bodies to make access control decisions?
 </pre>


#### Tool Output 
<pre>I don't know.</pre>

 Source Documents 

 | ID | Type | content_type |... language |... source | Page Content |
| --- | --- | --- | --- | --- | --- |
| None | Document | functions_classes | go | pkg/cli/cli_test.go | <details><summary>View Content</summary>type testPluginHandler struct { pluginsDirectory string validPrefixes []string // lookup results lookedup bool lookupErr error // execution results executed bool executedPlugin string withArgs []string withEnv []string }</details> |
| None | Document | simplified_code | go | pkg/cli/admin/policy/modify_roles_test.go | <details><summary>View Content</summary>// Code for: func TestModifyNamedClusterRoleBinding(t \*testing.T) { // Code for: func TestModifyNamedLocalRoleBinding(t \*testing.T) { // Code for: func TestModifyRoleBindingWarnings(t \*testing.T) { // compareResources compares resource equality then prints a diff for easier debugging // Code for: func compareResources(t \*testing.T, expected, actual interface{}) { // Code for: func getRoleBindingAbstractionsList(rbacClient rbacv1client.RbacV1Interface, namespace string) ([]\*roleBindingAbstraction, error) { // Code for: func modifyRoleAndCheck(t \*testing.T, o \*RoleModificationOptions, tcName, action string, expectedName string, expectedSubjects []rbacv1.Subject,</details> |
| None | Document | simplified_code | go | pkg/cli/gettoken/gettoken.go | <details><summary>View Content</summary>var ( getTokenLong = templates.LongDesc(` Experimental: This command is under development and may change without notice. Built-in Credential Exec plugin of the oc. It supports Auth Code, Auth Code + PKCE in addition to refresh token. get-token caches the ID token and Refresh token after the auth code flow is successfully completed and once ID token expires, command tries to get the new token by using the refresh token flow. Although it is optional, command also supports getting client secret to behave as an confidential client. `) getTokenExample = templates.Examples(` # Starts an auth code flow to the issuer url with the client id and the given extra scopes oc get-token --client-id=client-id --issuer-url=test.issuer.url --extra-scopes=email,profile</details> |
| None | Document | functions_classes | go | pkg/cli/gettoken/gettoken.go | <details><summary>View Content</summary>type GetTokenOptions struct { IssuerURL string ClientID string ClientSecret string ExtraScopes []string CallbackAdress string CACertFilename string InsecureTLS bool AutoOpenBrowser bool authenticator oidc.Authenticator tokenCache \*tokencache.Repository credWriter \*credwriter.Writer tokenCacheDir string authenticationTimeout time.Duration genericiooptions.IOStreams }</details> |




## Step 4 <a name='checklist-step-4' id='checklist-step-4'></a> : Check for Regression Impact


> **Input**: *Check for Regression Impact: Since this vulnerability is a regression of a previously fixed issue, verify if the containerized environment relies on authorization plugins that introspect the request or response body to make access control decisions. If so, assess the potential impact of this regression on the environment's security.*

> **Response**: *The container image does not appear to rely on authorization plugins that introspect the request or response body to make access control decisions, and the potential impact of the regression on the environment's security appears to be low.*

### Step 4.1 : *Container Image Code QA System*<a name='checklist-step-4.1' id='checklist-step-4.1'></a>


#### Action Log 
<pre>Thought: To answer this question, I need to determine if the containerized environment relies on authorization plugins that introspect the request or response body to make access control decisions. This requires checking the container image's code and configuration.

Action: Container Image Code QA System
Action Input: Does the container image use any authorization plugins that introspect the request or response body to make access control decisions?
 </pre>


#### Tool Input 
<pre>Does the container image use any authorization plugins that introspect the request or response body to make access control decisions?
 </pre>


#### Tool Output 
<pre>No, the provided context does not mention any authorization plugins that introspect the request or response body to make access control decisions.</pre>

 Source Documents 

 | ID | Type | content_type |... language |... source | Page Content |
| --- | --- | --- | --- | --- | --- |
| None | Document | functions_classes | go | pkg/helpers/image/helpers.go | <details><summary>View Content</summary>&quot; See https://github.com/containers/image/blob/main/docs/containers-auth.json.5.md for the order of podman registry config locations.\n&quot;</details> |
| None | Document | functions_classes | go | pkg/cli/set/triggers.go | <details><summary>View Content</summary>cmd.Flags().BoolVar(&amp;o.Local, &quot;local&quot;, o.Local, &quot;If true, set image will NOT contact api-server but run locally.&quot;) cmd.Flags().BoolVar(&amp;o.FromConfig, &quot;from-config&quot;, o.FromConfig, &quot;If set, configuration changes will result in a change&quot;) cmd.Flags().StringVarP(&amp;o.ContainerNames, &quot;containers&quot;, &quot;c&quot;, o.ContainerNames, &quot;Comma delimited list of container names this trigger applies to on deployments; defaults to the name of the only container&quot;) cmd.Flags().StringVar(&amp;o.FromImage, &quot;from-image&quot;, o.FromImage, &quot;An image stream tag to trigger off of&quot;) o.FromGitHub = cmd.Flags().Bool(&quot;from-github&quot;, false, &quot;If true, a GitHub webhook - a secret value will be generated automatically&quot;)</details> |
| None | Document | functions_classes | go | pkg/cli/tag/tag.go | <details><summary>View Content</summary>cmd.Flags().BoolVar(&amp;o.insecureTag, &quot;insecure&quot;, o.insecureTag, &quot;Set to true if importing the specified container image requires HTTP or has a self-signed certificate. Defaults to false.&quot;) cmd.Flags().StringVar(&amp;o.referencePolicy, &quot;reference-policy&quot;, SourceReferencePolicy, &quot;Allow to request pullthrough for external image when set to &#x27;local&#x27;. Defaults to &#x27;source&#x27;.&quot;) cmd.Flags().StringVar(&amp;o.importMode, &quot;import-mode&quot;, o.importMode, &quot;Imports the full manifest list of a tag when set to &#x27;PreserveOriginal&#x27;. Defaults to &#x27;Legacy&#x27;.&quot;)</details> |
| None | Document | simplified_code | go | pkg/cli/gettoken/gettoken.go | <details><summary>View Content</summary>var ( getTokenLong = templates.LongDesc(` Experimental: This command is under development and may change without notice. Built-in Credential Exec plugin of the oc. It supports Auth Code, Auth Code + PKCE in addition to refresh token. get-token caches the ID token and Refresh token after the auth code flow is successfully completed and once ID token expires, command tries to get the new token by using the refresh token flow. Although it is optional, command also supports getting client secret to behave as an confidential client. `) getTokenExample = templates.Examples(` # Starts an auth code flow to the issuer url with the client id and the given extra scopes oc get-token --client-id=client-id --issuer-url=test.issuer.url --extra-scopes=email,profile</details> |




[back to top](#checklist-toc)

### Step 4.2 : *Container Image Developer Guide QA System*<a name='checklist-step-4.2' id='checklist-step-4.2'></a>


#### Action Log 
<pre>Thought: The container image does not appear to use any authorization plugins that introspect the request or response body to make access control decisions. However, I need to verify if the container image relies on any other mechanisms that could be impacted by the regression.

Action: Container Image Developer Guide QA System
Action Input: What are the security mechanisms used by the container image to make access control decisions?
 </pre>


#### Tool Input 
<pre>What are the security mechanisms used by the container image to make access control decisions?
 </pre>


#### Tool Output 
<pre>Based on the provided context, the security mechanisms used by the container image to make access control decisions are:

1. Public key cryptography
2. Authentication using the identity attached to the public key
3. Multiple methods to prove possession of the private key associated with an identity, including:
	* TLS x509 certificates
	* Signature verification
	* Key Challenge
4. Authorization and access control managed through a distributed trust graph
5. Trust servers used as authorities of the trust graph, allowing caching of portions of the graph for faster access.

These mechanisms are provided by the libtrust library, which is used for managing authentication and authorization.</pre>

 Source Documents 

 | ID | Type | source | Page Content |
| --- | --- | --- | --- |
| None | Document | vendor/github.com/distribution/distribution/v3/GOVERNANCE.md | <details><summary>View Content</summary>## How are decisions made? Docker distribution is an open-source project with an open design philosophy. This means that the repository is the source of truth for EVERY aspect of the project, including its philosophy, design, road map, and APIs. \*If it&#x27;s part of the project, it&#x27;s in the repo. If it&#x27;s in the repo, it&#x27;s part of the project.\* As a result, all decisions can be expressed as changes to the repository. An implementation change is a change to the source code. An API change is a change to the API specification. A philosophy change is a change to the philosophy manifesto, and so on. All decisions affecting distribution, big and small, follow the same 3 steps: \* Step 1: Open a pull request. Anyone can do this. \* Step 2: Discuss the pull request. Anyone can do this.</details> |
| None | Document | vendor/github.com/distribution/reference/GOVERNANCE.md | <details><summary>View Content</summary>## How are decisions made? Docker distribution is an open-source project with an open design philosophy. This means that the repository is the source of truth for EVERY aspect of the project, including its philosophy, design, road map, and APIs. \*If it&#x27;s part of the project, it&#x27;s in the repo. If it&#x27;s in the repo, it&#x27;s part of the project.\* As a result, all decisions can be expressed as changes to the repository. An implementation change is a change to the source code. An API change is a change to the API specification. A philosophy change is a change to the philosophy manifesto, and so on. All decisions affecting distribution, big and small, follow the same 3 steps: \* Step 1: Open a pull request. Anyone can do this. \* Step 2: Discuss the pull request. Anyone can do this.</details> |
| None | Document | vendor/github.com/distribution/distribution/v3/README.md | <details><summary>View Content</summary># Distribution The toolset to pack, ship, store, and deliver content. This repository&#x27;s main product is the Open Source Registry implementation for storing and distributing container images using the [OCI Distribution Specification](https://github.com/opencontainers/distribution-spec). The goal of this project is to provide a simple, secure, and scalable base for building a large scale registry solution or running a simple private registry. It is a core library for many registry operators including Docker Hub, GitHub Container Registry, GitLab Container Registry and DigitalOcean Container Registry, as well as the CNCF Harbor Project, and VMware Harbor Registry. &lt;img src=&quot;/distribution-logo.svg&quot; width=&quot;200px&quot; /&gt;</details> |
| None | Document | vendor/github.com/docker/libtrust/README.md | <details><summary>View Content</summary># libtrust &gt; \*\*WARNING\*\* this library is no longer actively developed, and will be integrated &gt; in the [docker/distribution][https://www.github.com/docker/distribution] &gt; repository in future. Libtrust is library for managing authentication and authorization using public key cryptography. Authentication is handled using the identity attached to the public key. Libtrust provides multiple methods to prove possession of the private key associated with an identity. - TLS x509 certificates - Signature verification - Key Challenge Authorization and access control is managed through a distributed trust graph. Trust servers are used as the authorities of the trust graph and allow caching portions of the graph for faster access. ## Copyright and license</details> |




[back to top](#checklist-toc)

---
## References <a name='ref' id='ref'></a>  
Here are key references for further details on this vulnerability:
- https://github.com/moby/moby/commit/fc274cd2ff4cf3b48c91697fb327dd1fb95588fb
- https://github.com/moby/moby/commit/cc13f952511154a2866bddbb7dddebfe9e83b801
- https://ubuntu.com/security/notices/USN-7161-1
- https://www.cve.org/CVERecord?id=CVE-2024-41110
- https://github.com/moby/moby/security/advisories/GHSA-v23v-6jw2-98fq
- https://www.docker.com/blog/docker-security-advisory-docker-engine-authz-plugin/
- https://github.com/moby/moby/commit/411e817ddf710ff8e08fa193da80cb78af708191
- https://github.com/moby/moby/commit/65cc597cea28cdc25bea3b8a86384b4251872919
- https://github.com/moby/moby/commit/852759a7df454cbf88db4e954c919becd48faa9b
- https://github.com/moby/moby/commit/a79fabbfe84117696a19671f4aa88b82d0f64fc1
- https://github.com/moby/moby/commit/ae2b3666c517c96cbc2adf1af5591a6b00d4ec0f
- https://github.com/moby/moby/commit/a31260625655cff9ae226b51757915e275e304b0
- https://github.com/advisories/GHSA-v23v-6jw2-98fq
- https://nvd.nist.gov/vuln/detail/CVE-2024-41110
- https://github.com/moby/moby/commit/42f40b1d6dd7562342f832b9cd2adf9e668eeb76
- https://github.com/moby/moby/commit/ae160b4edddb72ef4bd71f66b975a1a1cc434f00
- https://www.docker.com/blog/docker-security-advisory-docker-engine-authz-plugin

[back to top](#cve-intro)
